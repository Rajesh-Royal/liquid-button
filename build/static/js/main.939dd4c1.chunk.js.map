{"version":3,"sources":["LiquidButton.js","LiquidButtonMain.js","serviceWorker.js","index.js"],"names":["LiquidButton","className","this","props","class","data-text","name","data-force-factor","data-layer-1-viscosity","data-layer-2-viscosity","data-layer-1-mouse-force","data-layer-2-mouse-force","data-layer-1-force-limit","data-layer-2-force-limit","data-color1","background","data-color2","firstcolor","data-color3","secondcolor","svg","options","dataset","id","constructor","xmlns","tension","width","height","margin","hoverFactor","gap","debug","forceFactor","color1","color2","color3","textColor","text","layers","points","viscosity","mouseForce","forceLimit","layerIndex","length","layer","path","document","createElementNS","appendChild","wrapperElement","body","parentElement","append","svgText","setAttribute","style","fontFamily","svgDefs","touches","noise","addEventListener","touchHandler","clearHandler","mouseHandler","initOrigins","animate","p1","p2","Math","sqrt","pow","x","y","pointIndex","point","dx","ox","random","dy","oy","d","f","vx","vy","touchIndex","touch","mx","my","md","mf","max","min","force","prev","next","dPrev","distance","dNext","line","dLine","cPrev","cNext","raf","update","draw","firstChild","removeChild","gradient","start","stop","svgWidth","svgHeight","fill","commands","push","join","textContent","createPoint","alpha","angle","PI","sin","cos","e","offsetX","offsetY","rect","getBoundingClientRect","changedTouches","pageX","left","pageY","top","preventDefault","__raf","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setTimeout","bind","button","querySelectorAll","liquidButton","Component","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.939dd4c1.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nclass LiquidButton extends Component {\n\n\n    render() {\n\n        return (\n          <div>\n            <svg className={this.props.class}\n              data-text={this.props.name}\n              data-force-factor=\"0.1\"\n              data-layer-1-viscosity=\"0.5\"\n              data-layer-2-viscosity=\"0.4\"\n              data-layer-1-mouse-force=\"400\"\n              data-layer-2-mouse-force=\"500\"\n              data-layer-1-force-limit=\"1\"\n              data-layer-2-force-limit=\"2\"\n              data-color1={this.props.background}\n              data-color2={this.props.firstcolor}\n              data-color3={this.props.secondcolor}>\n    \n            </svg>\n          </div>\n    \n        )\n    \n      }\n    \n      componentDidMount() {\n        const LiquidButton = class LiquidButton {\n          constructor(svg) {\n            const options = svg.dataset;\n            this.id = this.constructor.id || (this.constructor.id = 1);\n            this.constructor.id++;\n            this.xmlns = \"http://www.w3.org/2000/svg\";\n            this.tension = options.tension * 1 || 0.4;\n            this.width = options.width * 1 || 200;\n            this.height = options.height * 1 || 50;\n            this.margin = options.margin || 40;\n            this.hoverFactor = options.hoverFactor || -0.1;\n            this.gap = options.gap || 5;\n            this.debug = options.debug || false;\n            this.forceFactor = options.forceFactor || 0.2;\n            this.color1 = options.color1 || \"#ff4800\";\n            this.color2 = options.color2 || \"#ff4800\";\n            this.color3 = options.color3 || \"#ff4800\";\n            this.textColor = options.textColor || \"#FFFFFF\";\n            this.text = options.text || \"LiquidButton\";\n            this.svg = svg;\n            this.layers = [\n              {\n                points: [],\n                viscosity: 0.5,\n                mouseForce: 100,\n                forceLimit: 2\n              },\n    \n              {\n                points: [],\n                viscosity: 0.8,\n                mouseForce: 150,\n                forceLimit: 3\n              }];\n    \n    \n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\n              const layer = this.layers[layerIndex];\n              layer.viscosity =\n                options[\"layer-\" + (layerIndex + 1) + \"Viscosity\"] * 1 ||\n                layer.viscosity;\n              layer.mouseForce =\n                options[\"layer-\" + (layerIndex + 1) + \"MouseForce\"] * 1 ||\n                layer.mouseForce;\n              layer.forceLimit =\n                options[\"layer-\" + (layerIndex + 1) + \"ForceLimit\"] * 1 ||\n                layer.forceLimit;\n              layer.path = document.createElementNS(this.xmlns, \"path\");\n              this.svg.appendChild(layer.path);\n            }\n            this.wrapperElement = options.wrapperElement || document.body;\n            if (!this.svg.parentElement) {\n              this.wrapperElement.append(this.svg);\n            }\n    \n            this.svgText = document.createElementNS(this.xmlns, \"text\");\n            this.svgText.setAttribute(\"x\", \"50%\");\n            this.svgText.setAttribute(\"y\", \"50%\");\n            this.svgText.setAttribute(\"dy\", ~~(this.height / 8) + \"px\");\n            this.svgText.setAttribute(\"font-size\", ~~(this.height / 2));\n            this.svgText.style.fontFamily = \"sans-serif\";\n            this.svgText.setAttribute(\"text-anchor\", \"middle\");\n            this.svgText.setAttribute(\"pointer-events\", \"none\");\n            this.svg.appendChild(this.svgText);\n    \n            this.svgDefs = document.createElementNS(this.xmlns, \"defs\");\n            this.svg.appendChild(this.svgDefs);\n    \n            this.touches = [];\n            this.noise = options.noise || 0;\n            document.body.addEventListener(\"touchstart\", this.touchHandler);\n            document.body.addEventListener(\"touchmove\", this.touchHandler);\n            document.body.addEventListener(\"touchend\", this.clearHandler);\n            document.body.addEventListener(\"touchcancel\", this.clearHandler);\n            this.svg.addEventListener(\"mousemove\", this.mouseHandler);\n            this.svg.addEventListener(\"mouseout\", this.clearHandler);\n            this.initOrigins();\n            this.animate();\n          }\n    \n          get mouseHandler() {\n            return e => {\n              this.touches = [\n                {\n                  x: e.offsetX,\n                  y: e.offsetY,\n                  force: 1\n                }];\n    \n    \n            };\n          }\n    \n          get touchHandler() {\n            return e => {\n              this.touches = [];\n              const rect = this.svg.getBoundingClientRect();\n              for (\n                let touchIndex = 0;\n                touchIndex < e.changedTouches.length;\n                touchIndex++) {\n                const touch = e.changedTouches[touchIndex];\n                const x = touch.pageX - rect.left;\n                const y = touch.pageY - rect.top;\n                if (x > 0 && y > 0 && x < this.svgWidth && y < this.svgHeight) {\n                  this.touches.push({ x, y, force: touch.force || 1 });\n                }\n              }\n              e.preventDefault();\n            };\n          }\n    \n          get clearHandler() {\n            return e => {\n              this.touches = [];\n            };\n          }\n    \n          get raf() {\n            return (\n              this.__raf || (\n                this.__raf = (\n                  window.requestAnimationFrame ||\n                  window.webkitRequestAnimationFrame ||\n                  window.mozRequestAnimationFrame ||\n                  function (callback) {\n                    setTimeout(callback, 10);\n                  }).bind(window)));\n    \n          }\n    \n          distance(p1, p2) {\n            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n          }\n    \n          update() {\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\n              const layer = this.layers[layerIndex];\n              const points = layer.points;\n              for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {\n                const point = points[pointIndex];\n                const dx = point.ox - point.x + (Math.random() - 0.5) * this.noise;\n                const dy = point.oy - point.y + (Math.random() - 0.5) * this.noise;\n                const d = Math.sqrt(dx * dx + dy * dy);\n                const f = d * this.forceFactor;\n                point.vx += f * (dx / d || 0);\n                point.vy += f * (dy / d || 0);\n                for (\n                  let touchIndex = 0;\n                  touchIndex < this.touches.length;\n                  touchIndex++) {\n                  const touch = this.touches[touchIndex];\n                  let mouseForce = layer.mouseForce;\n                  if (\n                    touch.x > this.margin &&\n                    touch.x < this.margin + this.width &&\n                    touch.y > this.margin &&\n                    touch.y < this.margin + this.height) {\n                    mouseForce *= -this.hoverFactor;\n                  }\n                  const mx = point.x - touch.x;\n                  const my = point.y - touch.y;\n                  const md = Math.sqrt(mx * mx + my * my);\n                  const mf = Math.max(\n                    -layer.forceLimit,\n                    Math.min(layer.forceLimit, mouseForce * touch.force / md));\n    \n                  point.vx += mf * (mx / md || 0);\n                  point.vy += mf * (my / md || 0);\n                }\n                point.vx *= layer.viscosity;\n                point.vy *= layer.viscosity;\n                point.x += point.vx;\n                point.y += point.vy;\n              }\n              for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {\n                const prev = points[(pointIndex + points.length - 1) % points.length];\n                const point = points[pointIndex];\n                const next = points[(pointIndex + points.length + 1) % points.length];\n                const dPrev = this.distance(point, prev);\n                const dNext = this.distance(point, next);\n    \n                const line = {\n                  x: next.x - prev.x,\n                  y: next.y - prev.y\n                };\n    \n                const dLine = Math.sqrt(line.x * line.x + line.y * line.y);\n    \n                point.cPrev = {\n                  x: point.x - line.x / dLine * dPrev * this.tension,\n                  y: point.y - line.y / dLine * dPrev * this.tension\n                };\n    \n                point.cNext = {\n                  x: point.x + line.x / dLine * dNext * this.tension,\n                  y: point.y + line.y / dLine * dNext * this.tension\n                };\n    \n              }\n            }\n          }\n    \n          animate() {\n            this.raf(() => {\n              this.update();\n              this.draw();\n              this.animate();\n            });\n          }\n    \n          get svgWidth() {\n            return this.width + this.margin * 2;\n          }\n    \n          get svgHeight() {\n            return this.height + this.margin * 2;\n          }\n    \n          draw() {\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\n              const layer = this.layers[layerIndex];\n              if (layerIndex === 1) {\n                if (this.touches.length > 0) {\n                  while (this.svgDefs.firstChild) {\n                    this.svgDefs.removeChild(this.svgDefs.firstChild);\n                  }\n                  for (\n                    let touchIndex = 0;\n                    touchIndex < this.touches.length;\n                    touchIndex++) {\n                    const touch = this.touches[touchIndex];\n                    const gradient = document.createElementNS(\n                      this.xmlns,\n                      \"radialGradient\");\n    \n                    gradient.id = \"liquid-gradient-\" + this.id + \"-\" + touchIndex;\n                    const start = document.createElementNS(this.xmlns, \"stop\");\n                    start.setAttribute(\"stop-color\", this.color3);\n                    start.setAttribute(\"offset\", \"0%\");\n                    const stop = document.createElementNS(this.xmlns, \"stop\");\n                    stop.setAttribute(\"stop-color\", this.color2);\n                    stop.setAttribute(\"offset\", \"100%\");\n                    gradient.appendChild(start);\n                    gradient.appendChild(stop);\n                    this.svgDefs.appendChild(gradient);\n                    gradient.setAttribute(\"cx\", touch.x / this.svgWidth);\n                    gradient.setAttribute(\"cy\", touch.y / this.svgHeight);\n                    gradient.setAttribute(\"r\", touch.force);\n                    layer.path.style.fill = \"url(#\" + gradient.id + \")\";\n                  }\n                } else {\n                  layer.path.style.fill = this.color2;\n                }\n              } else {\n                layer.path.style.fill = this.color1;\n              }\n              const points = layer.points;\n              const commands = [];\n              commands.push(\"M\", points[0].x, points[0].y);\n              for (let pointIndex = 1; pointIndex < points.length; pointIndex += 1) {\n                commands.push(\n                  \"C\",\n                  points[(pointIndex + 0) % points.length].cNext.x,\n                  points[(pointIndex + 0) % points.length].cNext.y,\n                  points[(pointIndex + 1) % points.length].cPrev.x,\n                  points[(pointIndex + 1) % points.length].cPrev.y,\n                  points[(pointIndex + 1) % points.length].x,\n                  points[(pointIndex + 1) % points.length].y);\n    \n              }\n              commands.push(\"Z\");\n              layer.path.setAttribute(\"d\", commands.join(\" \"));\n            }\n            this.svgText.textContent = this.text;\n            this.svgText.style.fill = this.textColor;\n          }\n    \n          createPoint(x, y) {\n            return {\n              x: x,\n              y: y,\n              ox: x,\n              oy: y,\n              vx: 0,\n              vy: 0\n            };\n    \n          }\n    \n          initOrigins() {\n            this.svg.setAttribute(\"width\", this.svgWidth);\n            this.svg.setAttribute(\"height\", this.svgHeight);\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\n              const layer = this.layers[layerIndex];\n              const points = [];\n              for (\n                let x = ~~(this.height / 2);\n                x < this.width - ~~(this.height / 2);\n                x += this.gap) {\n                points.push(this.createPoint(x + this.margin, this.margin));\n              }\n              for (let alpha = ~~(this.height * 1.25); alpha >= 0; alpha -= this.gap) {\n                const angle = Math.PI / ~~(this.height * 1.25) * alpha;\n                points.push(\n                  this.createPoint(\n                    Math.sin(angle) * this.height / 2 +\n                    this.margin +\n                    this.width -\n                    this.height / 2,\n                    Math.cos(angle) * this.height / 2 + this.margin + this.height / 2));\n    \n    \n              }\n              for (\n                let x = this.width - ~~(this.height / 2) - 1;\n                x >= ~~(this.height / 2);\n                x -= this.gap) {\n                points.push(\n                  this.createPoint(x + this.margin, this.margin + this.height));\n    \n              }\n              for (let alpha = 0; alpha <= ~~(this.height * 1.25); alpha += this.gap) {\n                const angle = Math.PI / ~~(this.height * 1.25) * alpha;\n                points.push(\n                  this.createPoint(\n                    this.height -\n                    Math.sin(angle) * this.height / 2 +\n                    this.margin -\n                    this.height / 2,\n                    Math.cos(angle) * this.height / 2 + this.margin + this.height / 2));\n    \n    \n              }\n              layer.points = points;\n            }\n          }\n        };\n    \n        const buttons = document.querySelectorAll('.'+this.props.class);\n        let buttonIndex = 0;\n        const button = buttons[buttonIndex];\n        button.liquidButton = new LiquidButton(button);\n    \n    \n    \n        const redraw = () => {\n          button.initOrigins();\n        };\n    \n    \n    \n      }\n    }\n    \n    export default LiquidButton;","import React, { Component } from 'react'\r\n\r\nclass LiquidButtonMain extends Component {\r\n\r\n\r\n    render() {\r\n\r\n        return (\r\n          <div>\r\n            <svg className={this.props.class}\r\n              data-text={this.props.name}\r\n              data-force-factor=\"0.1\"\r\n              data-layer-1-viscosity=\"0.5\"\r\n              data-layer-2-viscosity=\"0.4\"\r\n              data-layer-1-mouse-force=\"400\"\r\n              data-layer-2-mouse-force=\"500\"\r\n              data-layer-1-force-limit=\"1\"\r\n              data-layer-2-force-limit=\"2\"\r\n              data-color1={this.props.background}\r\n              data-color2={this.props.firstcolor}\r\n              data-color3={this.props.secondcolor}>\r\n    \r\n            </svg>\r\n          </div>\r\n    \r\n        )\r\n    \r\n      }\r\n    \r\n      componentDidMount() {\r\n        const LiquidButton = class LiquidButton {\r\n          constructor(svg) {\r\n            const options = svg.dataset;\r\n            this.id = this.constructor.id || (this.constructor.id = 1);\r\n            this.constructor.id++;\r\n            this.xmlns = \"http://www.w3.org/2000/svg\";\r\n            this.tension = options.tension * 1 || 0.4;\r\n            this.width = options.width * 1 || 200;\r\n            this.height = options.height * 1 || 50;\r\n            this.margin = options.margin || 40;\r\n            this.hoverFactor = options.hoverFactor || -0.1;\r\n            this.gap = options.gap || 5;\r\n            this.debug = options.debug || false;\r\n            this.forceFactor = options.forceFactor || 0.2;\r\n            this.color1 = options.color1 || \"#ff4800\";\r\n            this.color2 = options.color2 || \"#ff4800\";\r\n            this.color3 = options.color3 || \"#ff4800\";\r\n            this.textColor = options.textColor || \"#FFFFFF\";\r\n            this.text = options.text || \"LiquidButton\";\r\n            this.svg = svg;\r\n            this.layers = [\r\n              {\r\n                points: [],\r\n                viscosity: 0.5,\r\n                mouseForce: 100,\r\n                forceLimit: 2\r\n              },\r\n    \r\n              {\r\n                points: [],\r\n                viscosity: 0.8,\r\n                mouseForce: 150,\r\n                forceLimit: 3\r\n              }];\r\n    \r\n    \r\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\r\n              const layer = this.layers[layerIndex];\r\n              layer.viscosity =\r\n                options[\"layer-\" + (layerIndex + 1) + \"Viscosity\"] * 1 ||\r\n                layer.viscosity;\r\n              layer.mouseForce =\r\n                options[\"layer-\" + (layerIndex + 1) + \"MouseForce\"] * 1 ||\r\n                layer.mouseForce;\r\n              layer.forceLimit =\r\n                options[\"layer-\" + (layerIndex + 1) + \"ForceLimit\"] * 1 ||\r\n                layer.forceLimit;\r\n              layer.path = document.createElementNS(this.xmlns, \"path\");\r\n              this.svg.appendChild(layer.path);\r\n            }\r\n            this.wrapperElement = options.wrapperElement || document.body;\r\n            if (!this.svg.parentElement) {\r\n              this.wrapperElement.append(this.svg);\r\n            }\r\n    \r\n            this.svgText = document.createElementNS(this.xmlns, \"text\");\r\n            this.svgText.setAttribute(\"x\", \"50%\");\r\n            this.svgText.setAttribute(\"y\", \"50%\");\r\n            this.svgText.setAttribute(\"dy\", ~~(this.height / 8) + \"px\");\r\n            this.svgText.setAttribute(\"font-size\", ~~(this.height / 2));\r\n            this.svgText.style.fontFamily = \"sans-serif\";\r\n            this.svgText.setAttribute(\"text-anchor\", \"middle\");\r\n            this.svgText.setAttribute(\"pointer-events\", \"none\");\r\n            this.svg.appendChild(this.svgText);\r\n    \r\n            this.svgDefs = document.createElementNS(this.xmlns, \"defs\");\r\n            this.svg.appendChild(this.svgDefs);\r\n    \r\n            this.touches = [];\r\n            this.noise = options.noise || 0;\r\n            document.body.addEventListener(\"touchstart\", this.touchHandler);\r\n            document.body.addEventListener(\"touchmove\", this.touchHandler);\r\n            document.body.addEventListener(\"touchend\", this.clearHandler);\r\n            document.body.addEventListener(\"touchcancel\", this.clearHandler);\r\n            this.svg.addEventListener(\"mousemove\", this.mouseHandler);\r\n            this.svg.addEventListener(\"mouseout\", this.clearHandler);\r\n            this.initOrigins();\r\n            this.animate();\r\n          }\r\n    \r\n          get mouseHandler() {\r\n            return e => {\r\n              this.touches = [\r\n                {\r\n                  x: e.offsetX,\r\n                  y: e.offsetY,\r\n                  force: 1\r\n                }];\r\n    \r\n    \r\n            };\r\n          }\r\n    \r\n          get touchHandler() {\r\n            return e => {\r\n              this.touches = [];\r\n              const rect = this.svg.getBoundingClientRect();\r\n              for (\r\n                let touchIndex = 0;\r\n                touchIndex < e.changedTouches.length;\r\n                touchIndex++) {\r\n                const touch = e.changedTouches[touchIndex];\r\n                const x = touch.pageX - rect.left;\r\n                const y = touch.pageY - rect.top;\r\n                if (x > 0 && y > 0 && x < this.svgWidth && y < this.svgHeight) {\r\n                  this.touches.push({ x, y, force: touch.force || 1 });\r\n                }\r\n              }\r\n              e.preventDefault();\r\n            };\r\n          }\r\n    \r\n          get clearHandler() {\r\n            return e => {\r\n              this.touches = [];\r\n            };\r\n          }\r\n    \r\n          get raf() {\r\n            return (\r\n              this.__raf || (\r\n                this.__raf = (\r\n                  window.requestAnimationFrame ||\r\n                  window.webkitRequestAnimationFrame ||\r\n                  window.mozRequestAnimationFrame ||\r\n                  function (callback) {\r\n                    setTimeout(callback, 10);\r\n                  }).bind(window)));\r\n    \r\n          }\r\n    \r\n          distance(p1, p2) {\r\n            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n          }\r\n    \r\n          update() {\r\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\r\n              const layer = this.layers[layerIndex];\r\n              const points = layer.points;\r\n              for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {\r\n                const point = points[pointIndex];\r\n                const dx = point.ox - point.x + (Math.random() - 0.5) * this.noise;\r\n                const dy = point.oy - point.y + (Math.random() - 0.5) * this.noise;\r\n                const d = Math.sqrt(dx * dx + dy * dy);\r\n                const f = d * this.forceFactor;\r\n                point.vx += f * (dx / d || 0);\r\n                point.vy += f * (dy / d || 0);\r\n                for (\r\n                  let touchIndex = 0;\r\n                  touchIndex < this.touches.length;\r\n                  touchIndex++) {\r\n                  const touch = this.touches[touchIndex];\r\n                  let mouseForce = layer.mouseForce;\r\n                  if (\r\n                    touch.x > this.margin &&\r\n                    touch.x < this.margin + this.width &&\r\n                    touch.y > this.margin &&\r\n                    touch.y < this.margin + this.height) {\r\n                    mouseForce *= -this.hoverFactor;\r\n                  }\r\n                  const mx = point.x - touch.x;\r\n                  const my = point.y - touch.y;\r\n                  const md = Math.sqrt(mx * mx + my * my);\r\n                  const mf = Math.max(\r\n                    -layer.forceLimit,\r\n                    Math.min(layer.forceLimit, mouseForce * touch.force / md));\r\n    \r\n                  point.vx += mf * (mx / md || 0);\r\n                  point.vy += mf * (my / md || 0);\r\n                }\r\n                point.vx *= layer.viscosity;\r\n                point.vy *= layer.viscosity;\r\n                point.x += point.vx;\r\n                point.y += point.vy;\r\n              }\r\n              for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {\r\n                const prev = points[(pointIndex + points.length - 1) % points.length];\r\n                const point = points[pointIndex];\r\n                const next = points[(pointIndex + points.length + 1) % points.length];\r\n                const dPrev = this.distance(point, prev);\r\n                const dNext = this.distance(point, next);\r\n    \r\n                const line = {\r\n                  x: next.x - prev.x,\r\n                  y: next.y - prev.y\r\n                };\r\n    \r\n                const dLine = Math.sqrt(line.x * line.x + line.y * line.y);\r\n    \r\n                point.cPrev = {\r\n                  x: point.x - line.x / dLine * dPrev * this.tension,\r\n                  y: point.y - line.y / dLine * dPrev * this.tension\r\n                };\r\n    \r\n                point.cNext = {\r\n                  x: point.x + line.x / dLine * dNext * this.tension,\r\n                  y: point.y + line.y / dLine * dNext * this.tension\r\n                };\r\n    \r\n              }\r\n            }\r\n          }\r\n    \r\n          animate() {\r\n            this.raf(() => {\r\n              this.update();\r\n              this.draw();\r\n              this.animate();\r\n            });\r\n          }\r\n    \r\n          get svgWidth() {\r\n            return this.width + this.margin * 2;\r\n          }\r\n    \r\n          get svgHeight() {\r\n            return this.height + this.margin * 2;\r\n          }\r\n    \r\n          draw() {\r\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\r\n              const layer = this.layers[layerIndex];\r\n              if (layerIndex === 1) {\r\n                if (this.touches.length > 0) {\r\n                  while (this.svgDefs.firstChild) {\r\n                    this.svgDefs.removeChild(this.svgDefs.firstChild);\r\n                  }\r\n                  for (\r\n                    let touchIndex = 0;\r\n                    touchIndex < this.touches.length;\r\n                    touchIndex++) {\r\n                    const touch = this.touches[touchIndex];\r\n                    const gradient = document.createElementNS(\r\n                      this.xmlns,\r\n                      \"radialGradient\");\r\n    \r\n                    gradient.id = \"liquid-gradient-\" + this.id + \"-\" + touchIndex;\r\n                    const start = document.createElementNS(this.xmlns, \"stop\");\r\n                    start.setAttribute(\"stop-color\", this.color3);\r\n                    start.setAttribute(\"offset\", \"0%\");\r\n                    const stop = document.createElementNS(this.xmlns, \"stop\");\r\n                    stop.setAttribute(\"stop-color\", this.color2);\r\n                    stop.setAttribute(\"offset\", \"100%\");\r\n                    gradient.appendChild(start);\r\n                    gradient.appendChild(stop);\r\n                    this.svgDefs.appendChild(gradient);\r\n                    gradient.setAttribute(\"cx\", touch.x / this.svgWidth);\r\n                    gradient.setAttribute(\"cy\", touch.y / this.svgHeight);\r\n                    gradient.setAttribute(\"r\", touch.force);\r\n                    layer.path.style.fill = \"url(#\" + gradient.id + \")\";\r\n                  }\r\n                } else {\r\n                  layer.path.style.fill = this.color2;\r\n                }\r\n              } else {\r\n                layer.path.style.fill = this.color1;\r\n              }\r\n              const points = layer.points;\r\n              const commands = [];\r\n              commands.push(\"M\", points[0].x, points[0].y);\r\n              for (let pointIndex = 1; pointIndex < points.length; pointIndex += 1) {\r\n                commands.push(\r\n                  \"C\",\r\n                  points[(pointIndex + 0) % points.length].cNext.x,\r\n                  points[(pointIndex + 0) % points.length].cNext.y,\r\n                  points[(pointIndex + 1) % points.length].cPrev.x,\r\n                  points[(pointIndex + 1) % points.length].cPrev.y,\r\n                  points[(pointIndex + 1) % points.length].x,\r\n                  points[(pointIndex + 1) % points.length].y);\r\n    \r\n              }\r\n              commands.push(\"Z\");\r\n              layer.path.setAttribute(\"d\", commands.join(\" \"));\r\n            }\r\n            this.svgText.textContent = this.text;\r\n            this.svgText.style.fill = this.textColor;\r\n          }\r\n    \r\n          createPoint(x, y) {\r\n            return {\r\n              x: x,\r\n              y: y,\r\n              ox: x,\r\n              oy: y,\r\n              vx: 0,\r\n              vy: 0\r\n            };\r\n    \r\n          }\r\n    \r\n          initOrigins() {\r\n            this.svg.setAttribute(\"width\", this.svgWidth);\r\n            this.svg.setAttribute(\"height\", this.svgHeight);\r\n            for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\r\n              const layer = this.layers[layerIndex];\r\n              const points = [];\r\n              for (\r\n                let x = ~~(this.height / 2);\r\n                x < this.width - ~~(this.height / 2);\r\n                x += this.gap) {\r\n                points.push(this.createPoint(x + this.margin, this.margin));\r\n              }\r\n              for (let alpha = ~~(this.height * 1.25); alpha >= 0; alpha -= this.gap) {\r\n                const angle = Math.PI / ~~(this.height * 1.25) * alpha;\r\n                points.push(\r\n                  this.createPoint(\r\n                    Math.sin(angle) * this.height / 2 +\r\n                    this.margin +\r\n                    this.width -\r\n                    this.height / 2,\r\n                    Math.cos(angle) * this.height / 2 + this.margin + this.height / 2));\r\n    \r\n    \r\n              }\r\n              for (\r\n                let x = this.width - ~~(this.height / 2) - 1;\r\n                x >= ~~(this.height / 2);\r\n                x -= this.gap) {\r\n                points.push(\r\n                  this.createPoint(x + this.margin, this.margin + this.height));\r\n    \r\n              }\r\n              for (let alpha = 0; alpha <= ~~(this.height * 1.25); alpha += this.gap) {\r\n                const angle = Math.PI / ~~(this.height * 1.25) * alpha;\r\n                points.push(\r\n                  this.createPoint(\r\n                    this.height -\r\n                    Math.sin(angle) * this.height / 2 +\r\n                    this.margin -\r\n                    this.height / 2,\r\n                    Math.cos(angle) * this.height / 2 + this.margin + this.height / 2));\r\n    \r\n    \r\n              }\r\n              layer.points = points;\r\n            }\r\n          }\r\n        };\r\n    \r\n        const buttons = document.querySelectorAll('.'+this.props.class);\r\n        let buttonIndex = 0;\r\n        const button = buttons[buttonIndex];\r\n        button.liquidButton = new LiquidButton(button);\r\n    \r\n    \r\n    \r\n        const redraw = () => {\r\n          button.initOrigins();\r\n        };\r\n    \r\n    \r\n    \r\n      }\r\n    }\r\n    \r\n    export default LiquidButtonMain;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport LiquidButton from './LiquidButton';\nimport LiquidButtonMain from './LiquidButtonMain';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<div><LiquidButton class=\"liquid-button\" name=\"FirstButton\" background=\"black\" firstcolor=\"#1e88e5\" secondcolor=\"yellow\" />\n                    <LiquidButton class=\"liquid-button2\" name=\"FirstButton\" background=\"black\" firstcolor=\"#1e88e5\" secondcolor=\"yellow\" />\n                    \n</div>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}